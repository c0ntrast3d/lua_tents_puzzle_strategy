---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by c0ntrast3d.
---

local TableUtils = require('utils.TableUtils')

stringifyMap = function(tentMap)
    local result = ''
    if not tentMap then
        return
    end
    for row = 1, #tentMap do
        for col = 1, #tentMap do
            local char
            local currentType = tentMap[row][col]
            if currentType == '?' then
                char = '?'
            elseif currentType == 'X' then
                char = '▲'
            elseif currentType == '.' then
                char = '.'
            elseif currentType == 'O' then
                char = 'T'
            end
            result = result .. char
        end
        result = result .. '\n'
    end
    return result
end

local board = {
    { '?', 'O', '?', 'O', '?', '?' },
    { '?', '?', '?', '?', 'O', '?' },
    { 'O', '?', 'O', '?', '?', '?' },
    { '?', '?', '?', '?', '?', 'O' },
    { 'O', '?', '?', '?', '?', '?' },
    { '?', '?', '?', '?', '?', '?' }
}
local rowHints = { 2, 1, 1, 2, 1, 0 }
local colHints = { 2, 0, 2, 0, 2, 1 }
local rowTentCount = { 0, 0, 0, 0, 0, 0 }
local colTentCount = { 0, 0, 0, 0, 0, 0 }

--[[ Displays the ascii graphic representing the global game board ]]
local function printBoard()
    local space = '   '
    local borderTop = space .. '_' .. string.rep("__", #board)
    local borderBottom = space .. '¯' .. string.rep("¯", #board * 2)
    local count = 1
    local bottom = ""
    print(borderTop)
    for row = 1, #board do
        local toPrint = ""
        for col = 1, #board do
            toPrint = toPrint .. board[row][col] .. " "
        end
        print(rowHints[count] .. " | " .. toPrint .. '|')
        bottom = bottom .. colHints[count] .. " "
        count = count + 1
    end
    print(borderBottom)
    print(space .. ' ' .. bottom .. ' ')
end
--[[ Checks whether a move at <row, col> is valid within the rules
of tents and trees ]]
function isValid(row, col, caller)
    if isValidSum(row, col, '~~ isValid ~~') and isValidParity(row, col, '~~ isValid ~~') and noAdjTents(row, col, '~~ isValid ~~') then
        return true
    end
    return false
end
--[[ Checks whether placing a tent at <row,col> would exceed any of
the given row or column numbers ]]
function isValidSum(x, y, caller)
    if rowTentCount[x] + 1 > rowHints[x] then
        return false
    end
    if colTentCount[y] + 1 > colHints[y] then
        return false
    end
    return true
end
--[[ Checks the parity of trees to tents. Essentially, it moves
between a connected chain of tent/tree pairs, and makes sure at
the end the number of trees matches the number of tents ]]
function isValidParity(x, y, caller)
    local parity = -1
    pred = { { x, y } }
    for k, v in pairs(getNeighbors(x, y, '~~ isValidParity ~~')) do
        parity = parity + countTreesRec(v[1], v[2], pred)
    end
    if (parity >= 0) then
        return true
    end
    return false
end
--[[
Helper function for isValidParity. Called on a tent
to check for any trees around it, and recursively return the tree
to tent parity.
 ]]

function countTreesRec(x, y, pred)
    table.insert(pred, { x, y })
    if (board[x][y] == "O") then
        local parity = 1
        for k, v in pairs(getNeighbors(x, y, '~~ countTreesRec ~~')) do
            if (not TableUtils.tableContainsTable(v, pred)) then
                parity = parity + countTentsRec(v[1], v[2], pred)
            end
        end
        return parity
    else
        return 0
    end
end
--[[
Helper function for isValidParity. Called on a tree to
check for any tents around it, and recursively return the tree
to tent parity.
 ]]
function countTentsRec(x, y, pred)
    table.insert(pred, { x, y })
    if (board[x][y] == "X") then
        local parity = -1
        for k, v in pairs(getNeighbors(x, y, '~~ countTentsRec ~~')) do
            if (not TableUtils.tableContainsTable(v, pred)) then
                parity = parity + countTreesRec(v[1], v[2], pred)
            end
        end
        return parity
    end
    return 0
end
--[[
Check that there are no tents adjacent to a given location
 ]]
function noAdjTents(x, y)
    for k, v in pairs(getTentAdjacent(x, y)) do
        if (board[v[1]][v[2]] == "X") then
            return false
        end
    end
    return true
end
--[[
Get the vertical and horizontal neighbors at a given
grid coordinate, returned as a list of coordinates.
 ]]
function getNeighbors(x, y, caller)
    local neighbors = {}
    if (x > 1) then
        table.insert(neighbors, { x - 1, y })
    end
    if x < #board then
        table.insert(neighbors, { x + 1, y })
    end
    if y > 1 then
        table.insert(neighbors, { x, y - 1 })
    end
    if y < #board then
        table.insert(neighbors, { x, y + 1 })
    end
    return neighbors
end
--[[
Get the vertical, horizontal, and diagonal neighbors at a given
grid coordinate, returned as a list of coordinates.
 ]]
function getTentAdjacent(x, y)

    local neighbors = getNeighbors(x, y, '~~ getTentAdjacent ~~')
    if x > 1 and y > 1 then
        table.insert(neighbors, { x - 1, y - 1 })
    end
    if x > 1 and y < #board - 1 then
        table.insert(neighbors, { x - 1, y + 1 })
    end
    if x < #board - 1 and y > 1 then
        table.insert(neighbors, { x + 1, y - 1 })
    end
    if x < #board and y < #board - 1 then
        table.insert(neighbors, { x + 1, y + 1 })
    end
    return neighbors
end
--[[
Polls for an unknown space, and if it finds one,
returns it as a coordinate.
 ]]
function findUnknown(caller)
    for row = 1, #board do
        for col = 1, #board do
            if board[row][col] == "?" then
                return row, col
            end
        end
    end
    return nil
end


--[[
Checks the board against the game constraints
to see whether or not we have reached a goal
state. Returns true if so, false otherwise.
 ]]
function isGoal()
    local totalRowTents = 0
    local totalColTents = 0
    for row = 1, #board do
        for col = 1, #board do
            if board[row][col] == "X" then
                totalRowTents = totalRowTents + 1
            end
        end
        if (totalRowTents ~= rowHints[row]) then
            return false
        else
            totalRowTents = 0
        end
    end
    for col = 1, #board do
        for row = 1, #board do
            if (board[row][col] == "X") then
                totalColTents = totalColTents + 1
            end
        end
        if (totalColTents ~= colHints[col]) then
            return false
        else
            totalColTents = 0
        end
    end
    return true
end


--[[
Mark any spaces not adjacent to a tree as grass
 ]]
function markNotAdjacentAsGrass()
    for row = 1, #board do
        for col = 1, #board do
            if (board[row][col] ~= "O") then
                board[row][col] = "."
                for k, v in ipairs(getNeighbors(row, col, '~~ markNotAdjacentAsGrass ~~')) do
                    if board[v[1]][v[2]] == "O" then
                        board[row][col] = "?"
                        break
                    end
                end
            end
        end
    end
end

--[[
Marks any spaces adjacent to a placed tent as grass
 ]]
function markTentAdjGrass(x, y, caller)
    for k, v in pairs(getTentAdjacent(x, y)) do
        if (board[v[1]][v[2]] ~= "O") then
            board[v[1]][v[2]] = "."
        end
    end
end
--[[
Checks the row and column numbers, then marks
any rows or columns with a 0 as grass. Also
checks to see if any of them have the same number
of open spaces as tents needed, and if they do, fills
in those spaces with tents.
 ]]
function markNonBranching()
    local totalRowOccupants = 0
    local totalColOccupants = 0
    for row = 1, #board do
        for col = 1, #board do
            if board[row][col] == "O" or board[row][col] == "." then
                totalRowOccupants = totalRowOccupants + 1
            end
            if rowHints[row] == 0 and board[row][col] ~= "O" then
                board[row][col] = "."
            end
        end
        if #board - totalRowOccupants == rowHints[row] then
            for j = 1, #board do
                if (board[row][j] == "?") then
                    board[row][j] = "X"
                end
            end
        end
        totalRowOccupants = 0
    end
    for col = 1, #board do
        for row = 1, #board do
            if board[row][col] == "O" or board[row][col] == "." then
                totalColOccupants = totalColOccupants + 1
            end
            if colHints[col] == 0 and board[row][col] ~= "O" then
                board[row][col] = "."
            end
        end
        if #board - totalColOccupants == colHints[col] then
            for i = 1, #board do
                if (board[i][col] == "?") then
                    board[i][col] = "X"
                end
            end
        end
        totalColOccupants = 0
    end
end
--[[
Checks the given row and column numbers, then
checks to see if they have the same number
of open spaces as tents needed, and if they do,
fills n those spaces with tents. Compares number
of tents to row and column numbers, and if equal,
fills in the rest of the spaces with grass.
 ]]
function markTentRowCol(x, y, caller)
    local totalRowOccupants = 0
    local totalColOccupants = 0

    for col = 1, #board do
        if board[x][col] == "O" or board[x][col] == "." or board[x][col] == "X" then
            totalRowOccupants = totalRowOccupants + 1
        end
        col = col
    end

    if #board - totalRowOccupants == rowHints[x] then
        for j = 1, #board do
            if board[x][j] == "?" then
                board[x][j] = "X"
            end
        end
    end

    if rowHints[x] == rowTentCount[x] then
        for j = 1, #board do
            if board[x][j] == "?" then
                board[x][j] = "."
            end
        end
    end

    for row = 1, #board do
        if board[row][y] == "O" or board[row][y] == "." or board[row][y] == "X" then
            totalColOccupants = totalColOccupants + 1
        end
    end

    if #board - totalColOccupants == colHints[ncol] then
        for i = 1, #board do
            if (board[i][y] == "?") then
                board[i][y] = "X"
            end
        end
        if (colHints[y] == colTentCount[y]) then
            for i = 1, #board do
                if (board[i][y] == "?") then
                    board[i][y] = "."
                end
            end
        end
    end
end -- markTentRowCol END
--[[
Primary function to start the solving process. Runs the pre-move
strategies, then calls the recursive solver.
 ]]
local function solve()
    markNotAdjacentAsGrass()
    markNonBranching()
    markNonBranching()
    if (findUnknown('~~ solve ~~') ~= nil) then
        row, col = findUnknown('~~ solve :: FU NOT NULL ~~')
        return solveRec(row, col, '~~ solve ~~')
    elseif isGoal() then
        return true
    else
        return nil
    end
end
--[[
Recursive solver function. Checks for an empty
spot, then attempts to put a tent there. Runs the
other strategies, then recurse. If there are no
unknowns left, it checks to see if we've reached a goal
state; if we have, it returns true to signify the goal
has been reached.
 ]]

saveState = function()
    local state = {}
    state.board = TableUtils.deepcopy(board)
    state.rowHints = TableUtils.deepcopy(rowHints)
    state.colHints = TableUtils.deepcopy(colHints)
    state.rowTentCount = TableUtils.deepcopy(rowTentCount)
    state.colTentCount = TableUtils.deepcopy(colTentCount)
    return state
end

local restoreState = function(previous)
    board = previous.board
    rowHints = previous.rowHints
    colHints = previous.colHints
    rowTentCount = previous.rowTentCount
    colTentCount = previous.colTentCount
end

function solveRec(row, col, caller)
    row, col = row, col
    printBoard()
    local currentState = saveState()
    if isValid(row, col, '~~ solveRec ~~') then
        board[row][col] = "X"
        colTentCount[col] = colTentCount[col] + 1
        rowTentCount[row] = rowTentCount[row] + 1
        markTentAdjGrass(row, col, '~~ solveRec ~~')
        markTentRowCol(row, col, '~~ solveRec ~~')
        if findUnknown('~~ solveRec ~~') ~= nil then
            row, col = findUnknown('~~ solveRec ~~ :: FU NOT NULL')
            if solveRec(row, col, '~~ solveRec ~~') == true then
                return true
            else
                restoreState(currentState)
                board[row][col] = "."
                check = solveRec(row, col, '~~ solveRec ~~')
                if check == true then
                    return true
                else
                    return nil
                end
            end
        else
            if isGoal() then
                return true
            else
                return nil
            end
        end

    else
        board[row][col] = "."
        if (findUnknown('~~ solveRec ~~') ~= nil) then
            row, col = findUnknown('~~ solveRec ~~ :: FU NOT NULL')
            if solveRec(row, col, '~~ solveRec ~~') then
                return true
            else
                return nil
            end
        else
            if isGoal() then
                return true
            else
                return nil
            end
        end
    end

end
--[[
In all but name, my main function. Starts everything.
 ]]
printBoard()
if solve() then
    print("Found a solution: ")
    printBoard()
else
    print("No solution found")
    printBoard()
end