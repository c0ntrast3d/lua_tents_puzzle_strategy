---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by c0ntrast3d.
---

local M = {}

local SolverHelpers = require('solver.SolverHelpers')
local MapPrinter = require('io.MapPrinter')
local TableUtils = require('utils.TableUtils')

local map = {}
local rowHints = {}
local colHints = {}
local rowTentCount = {}
local colTentCount = {}

--[[
    if cell is valid for a tent according to the rules -> place a tent
]]

function isValid(row, col)
    if checkSum(row, col) and checkParity(row, col) and noAdjTents(row, col) then
        return true
    end
    return false
end

--[[
Placing a tent in a cell should not exceed the hints limit
]]
function checkSum(x, y)
    if rowTentCount[x] + 1 > rowHints[x] then
        return false
    end
    if colTentCount[y] + 1 > colHints[y] then
        return false
    end
    return true
end

--[[
The number of threes and tents should be the same.
]]

function checkParity(x, y)
    local parity = -1
    pred = { { x, y } }
    for k, v in pairs(getNeighbors(x, y, '~~ isValidParity ~~')) do
        parity = parity + countTrees(v[1], v[2], pred)
    end
    if (parity >= 0) then
        return true
    end
    return false
end

--[[
isValidParity helper.
check for trees around a tent.
recursively return the tree to tent parity.
]]

function countTrees(x, y, visited)
    table.insert(visited, { x, y })
    if (map[x][y] == "T") then
        local parity = 1
        for k, v in pairs(getNeighbors(x, y, '~~ countTreesRec ~~')) do
            if (not TableUtils.tableContainsTable(v, visited)) then
                parity = parity + countTents(v[1], v[2], visited)
            end
        end
        return parity
    else
        return 0
    end
end

--[[
isValidParity helper.
check for any tents around a tree.
recursively return the tree to tent parity.
 ]]

function countTents(x, y, pred)
    table.insert(pred, { x, y })
    if map[x][y] == "▲" then
        local parity = -1
        for k, v in pairs(getNeighbors(x, y, '~~ countTentsRec ~~')) do
            if (not TableUtils.tableContainsTable(v, pred)) then
                parity = parity + countTrees(v[1], v[2], pred)
            end
        end
        return parity
    end
    return 0
end

--[[
Check that there are no tents adjacent to a given location
 ]]

function noAdjTents(x, y)
    for k, v in pairs(getTentAdjacent(x, y)) do
        if (map[v[1]][v[2]] == "▲") then
            return false
        end
    end
    return true
end

--[[
get vertical and horizontal neighbors of a cell
 ]]

function getNeighbors(x, y)
    local neighbors = {}
    if (x > 1) then
        table.insert(neighbors, { x - 1, y })
    end
    if x < #map then
        table.insert(neighbors, { x + 1, y })
    end
    if y > 1 then
        table.insert(neighbors, { x, y - 1 })
    end
    if y < #map then
        table.insert(neighbors, { x, y + 1 })
    end
    return neighbors
end

--[[
get vertical, horizontal, and diagonal neighbors of a cell
 ]]

function getTentAdjacent(x, y)

    local neighbors = getNeighbors(x, y, '~~ getTentAdjacent ~~')
    if x > 1 and y > 1 then
        table.insert(neighbors, { x - 1, y - 1 })
    end
    if x > 1 and y < #map - 1 then
        table.insert(neighbors, { x - 1, y + 1 })
    end
    if x < #map - 1 and y > 1 then
        table.insert(neighbors, { x + 1, y - 1 })
    end
    if x < #map and y < #map - 1 then
        table.insert(neighbors, { x + 1, y + 1 })
    end
    return neighbors
end

--[[
search for unknown cell
 ]]

function findUnknownCells()
    for row = 1, #map do
        for col = 1, #map do
            if map[row][col] == "?" then
                return row, col
            end
        end
    end
    return nil
end


--[[
check the goal is reached
each col / row contains same number of tents as of hints
 ]]
function isGoal()
    local totalRowTents = 0
    local totalColTents = 0
    for row = 1, #map do
        for col = 1, #map do
            if map[row][col] == "▲" then
                totalRowTents = totalRowTents + 1
            end
        end
        if (totalRowTents ~= rowHints[row]) then
            return false
        else
            totalRowTents = 0
        end
    end
    for col = 1, #map do
        for row = 1, #map do
            if (map[row][col] == "▲") then
                totalColTents = totalColTents + 1
            end
        end
        if (totalColTents ~= colHints[col]) then
            return false
        else
            totalColTents = 0
        end
    end
    return true
end


--[[
mark cells not adjacent to a tree as grass
 ]]
function markNotAdjacentAsGrass()
    for row = 1, #map do
        for col = 1, #map do
            if (map[row][col] ~= 'T') then
                map[row][col] = "."
                for k, v in ipairs(getNeighbors(row, col, '~~ markNotAdjacentAsGrass ~~')) do
                    if map[v[1]][v[2]] == 'T' then
                        map[row][col] = "?"
                        break
                    end
                end
            end
        end
    end
    MapPrinter.printMap(map, rowHints, colHints)
end

--[[
mark cells adjacent to a placed tent as grass
 ]]
function markGrass(x, y)
    for k, v in pairs(getTentAdjacent(x, y)) do
        if (map[v[1]][v[2]] ~= 'T') then
            map[v[1]][v[2]] = "."
        end
    end
end

--[[
mark row / col with zero hints as grass
check whether some row / col have the same number
of unknown spaces and tents based on hints -> if true -> mark as tents
 ]]

function markZeroHintsOrUnknown()
    local totalRowOccupied = 0
    local totalColOccupied = 0
    for row = 1, #map do
        for col = 1, #map do
            if map[row][col] == 'T' or map[row][col] == "." then
                totalRowOccupied = totalRowOccupied + 1
            end
            if rowHints[row] == 0 and map[row][col] ~= 'T' then
                map[row][col] = "."
            end
        end
        if #map - totalRowOccupied == rowHints[row] then
            for j = 1, #map do
                if (map[row][j] == "?") then
                    map[row][j] = "▲"
                end
            end
        end
        totalRowOccupied = 0
    end
    for col = 1, #map do
        for row = 1, #map do
            if map[row][col] == 'T' or map[row][col] == "." then
                totalColOccupied = totalColOccupied + 1
            end
            if colHints[col] == 0 and map[row][col] ~= 'T' then
                map[row][col] = "."
            end
        end
        if #map - totalColOccupied == colHints[col] then
            for i = 1, #map do
                if (map[i][col] == "?") then
                    map[i][col] = "▲"
                end
            end
        end
        totalColOccupied = 0
    end
    MapPrinter.printMap(map, rowHints, colHints)
end

--[[
check whether some row / col have the same number
of unknown spaces and tents based on hints -> if true -> mark as tents
then compare number of tents to hints -> if true -> mark remaining as grass
 ]]

function markTents(x, y)
    local totalRowOccupants = 0
    local totalColOccupants = 0

    for col = 1, #map do
        if map[x][col] == 'T' or map[x][col] == "." or map[x][col] == "▲" then
            totalRowOccupants = totalRowOccupants + 1
        end
    end

    if #map - totalRowOccupants == rowHints[x] then
        for col = 1, #map do
            if map[x][col] == "?" then
                map[x][col] = "▲"
            end
        end
    end

    if rowHints[x] == rowTentCount[x] then
        for col = 1, #map do
            if map[x][col] == "?" then
                map[x][col] = "."
            end
        end
    end

    for row = 1, #map do
        if map[row][y] == 'T' or map[row][y] == "." or map[row][y] == "▲" then
            totalColOccupants = totalColOccupants + 1
        end
    end

end

--[[
prepare the map with iterative helpers then run recursive solver
 ]]

local function prepareThenSolve()
    markNotAdjacentAsGrass()
    markZeroHintsOrUnknown()
    if (findUnknownCells() ~= nil) then
        row, col = findUnknownCells()
        return solve(row, col)
    elseif isGoal() then
        return true
    else
        return nil
    end
end

local saveState = function()
    local state = {}
    state.board = TableUtils.deepcopy(map)
    state.rowHints = TableUtils.deepcopy(rowHints)
    state.colHints = TableUtils.deepcopy(colHints)
    state.rowTentCount = TableUtils.deepcopy(rowTentCount)
    state.colTentCount = TableUtils.deepcopy(colTentCount)
    return state
end

local restoreState = function(previous)
    map = previous.board
    rowHints = previous.rowHints
    colHints = previous.colHints
    rowTentCount = previous.rowTentCount
    colTentCount = previous.colTentCount
end

--[[
check for unknown cell, then attempt to put a tent.
run iterative helpers and continue recursion
 ]]

function solve(row, col)
    row, col = row, col
    local currentState = saveState()
    if isValid(row, col) then
        map[row][col] = "▲"
        colTentCount[col] = colTentCount[col] + 1
        rowTentCount[row] = rowTentCount[row] + 1
        markGrass(row, col)
        markTents(row, col)

        if findUnknownCells() ~= nil then
            row, col = findUnknownCells()
            if solve(row, col) == true then
                return true
            else
                restoreState(currentState)
                map[row][col] = "."
                check = solve(row, col)
                if check == true then
                    return true
                else
                    return nil
                end
            end
        else
            if isGoal() then
                return true
            else
                return nil
            end
        end

    else
        map[row][col] = "."
        if (findUnknownCells() ~= nil) then
            row, col = findUnknownCells()
            if solve(row, col) then
                return true
            else
                return nil
            end
        else
            if isGoal() then
                return true
            else
                return nil
            end
        end
    end

end

-- start the magic
M.start = function(readerOutput)
    map = readerOutput.map
    rowHints = readerOutput.rowHints
    colHints = readerOutput.colHints
    rowTentCount, colTentCount = SolverHelpers.initCounts(readerOutput.mapDimension)
    MapPrinter.printMap(map, rowHints, colHints)
    if prepareThenSolve() then
        print('\nFound a solution:')
        MapPrinter.printMap(map, rowHints, colHints)
    else
        print('\nNo solution found')
        MapPrinter.printMap(map, rowHints, colHints)
    end
end

return M